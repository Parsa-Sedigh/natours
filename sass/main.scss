@import "abstracts/_functions";
@import "abstracts/_mixins";
@import "abstracts/_variables";

@import "base/base";
@import "base/animations";
@import "base/_typography.scss";
@import "base/_utilities.scss";

@import "components/_button.scss";
@import "components/_logo.scss";
@import "components/composition";
@import "components/feature-box";
@import "components/card";
@import "components/story";
@import "components/bg-video";
@import "components/form";
@import "components/popup";

@import "layout/header";
@import "layout/_grid.scss";
@import "layout/footer";
@import "layout/navigation";

@import "pages/_home.scss";

/*
light-green:#7ed56f
medium-green:#55c57a
dark green:#28b485
 */
/*
 What you will learn in this section:
 1)...

 ) How to make text flow around shapes with shape-outside and floats
 ) how to apply filter to images
 ) how to create a background video covering an entire section
 ) How to use <video> html element
 ) How and when to use object-fit property
 */

/* How cascade actually resolves the conflicts when more than 1 rule applies? In order to determine which one takes precedence
 it looks at the importance, at the selector specificity and the source order of conflicting declarations.
 First the cascade starts by giving the conflicting declarations different importances based on where they declared.So based on
  their source. The order of importance is :
  1) User !important declarations. (User: the visitor of website can manipulate the CSS and ... on website, right?)
  2) Author !important declarations (Author: Is the developer)
  3) Author declarations
  4) User declarations
  5) Default browser declarations

  But in the most scenarios, we have declarations with same importance, so we check the `specificity of the declaration selectors` :
  1) Inline styles (have the highest specificity)
  2) IDs
  3) classes, pseudo classes, attribute selectors
  4) elements, pseudo element selectors

  Now how calculate specificity based on the priorities that I mentioned? (Inline, ids, classes, elements), for number of
   occurances we +1 , For example:
   nav#nav div.pull-right .button {

   }

In above, we have the specificity of (0, 1, 2, 2)
Remember: The value of the winning declaration is called the cascaded value.

If the importance and specificity were equal between two or more selectors, then the last CSS declaration written in the code
is the one that will apply.

A selector that contains 1 id is more specific than 1 with 1000 classes. and this is true about classes and elements.
Universal selector has no specificity value which means that all other selectors have a precedence over it.

Rely more on specificity rather than order of selectors. But rely on order when using 3rd party stylesheets-always put your
author stylesheet last.
 */
/* How values are processed in CSS parsing phase?

Important: We have relative units, but there is difference in using relative units for fonts or for length measurements:

% for fonts: When you declare a font-size in %, it would related to parent's font-size.
% for length: But when you declare a length in %, it works a bit different.Because when we express a length measurement in percentages,
like height or width or padding or margin or something else, the reference of that % is always the parent's WIDTH.

Next we have font-based relative units like em and rem and again there's difference to use ems for fonts.
Both ems and rems are font-based, but the difference between them is that em uses the parent or the current element as reference
while rem uses the root font-size as reference.
If we want to use ems for font-sizes, then the reference is simply the parent's computed font-size, similar to what happens with
percentages. But for length the reference for em is the font-size of the current element.

Now for rem, font-size and length work the same way. Because rem always uses the root font-size as the reference.
em for fonts:
em for lengths:
rem:

vh and vw are viewport-based units. 1vh is just 1 percent of the viewport's height and 1vw is 1 percent of viewport's width
*/
/* Each CSS property has an initial value which is used if nothing else is declared and if there is no inheritance.
  Browsers specify a root font-size for each page (usually 16px) and this is a user agent definition so it's not an initial value
  that is coming from the CSS specification.
  Percentages are measured relative to their paren'ts font=size, if used to specify font-size.
  Percentages are measured relative to their parent's width, if used to specify length.
  ems are measured relative to their parent's font-size if used to specify font-size.
  ems are measured relative to CURRENT font-size if used to specify length.
  rems are ALWAYS measured relative to document's root font-size.
  vh and vw are simply percentage measurements of the viewport's height and width.*/
/* Each and every CSS property must have a value. Even if neither we nor the browser do specify it. In that case there's no
 cascaded value.For processing a value for a certain element, the first question that css engine asks is : Is there a cascaded value?
 and if there is, that's the value that is used for the property. So specified value = cascaded value . But if there's no cascaded value,
 then the next question is if the property can be inherited and that depends on each property. Because there are some properties
 that are inherited and others are not (for example, line-height gets inherited.).
  So if the property is inherited, then the value
  of that property becomes the computed value of it's parent element. So in this case the specified value = computed value of parent.(This
  is inheritance!!!)
 Example:
 .parent {
    font-size:20px;
    line-height:150%;
 }
 .child {
    font-size:25px;
 }

 In this example, the value that get's inherited by child is not simply the 150% but the computed value of parent and in this case the
 computed value of parent is 150% of 20px. Which is 30px. So the line-height of the child element would be 30px not 150% of that 25px.
 Now if it's a property that get's not inherited, like padding, then the specified value will become the initial value.Which is also
 specific to each property. But you don't need to memorize these initial values.Because they're intuitive.
 So in this case: specified value = initial value (specific to each property)

 RECAP:
 *Inheritance passes the values for some specific properties from parents to children.Inheritance allows developers to write less
 code and code will be mor maintainable.

 *Properties related to text are inherited, like font-family, color and ... (in specification you will find if the property is
 automatically inherited or not?)- Other properties like margin and padding are not inherited, because it would be impracticable.

 *Important: The computed value is what get's inherited, not the declared value.
 *Inheritance of a property works if no one (neither developer nor browser) declares a value for that property.
 *We can use inherit keyword to force the inheritance of a certain property.
 *The initial keyword resets a property to it's initial value.
 */
/* Converting px to rem:
 We must change all absolute px units to relative rem units. Why? Because we want an easy way to change all measurements on our
 page with one simple setting. For example, when we hit a break point to display our page on a mobile device. When that happens,
 we want a way to decrease all the measurements in our site at the same time and instead of writing too many code in media queries,
 we can just change global font-size.(rem units are in relation to root font-size). The root font-size is set in the html selector.\
 So we must remove the font-size in body selector. But why 10px for root font-size?
 Because it's easier. Important: We know that 1rem is exactly equal to root font-size and in this case the root font-size is 10px.
 So now 1rem is 10px. So now for converting px units to rem, all we have to do is divide the px by 10 and it would be rem.
 Still, it's a bad practice that the root font-size is still in px units. But the problem is that by doing so, we actually
 override the browser's font-size setting that the user can manually change in the settings.So some people increase the default font-size
 of their browser. Now if we set the font to something like 10xp, then we remove the ability for those people to see our website properly!
 Because they can't no longer change the default font-size.Well, they can!!! but our root font-size won't be affected by changes that
 those people do.
 So we must make the overall root font-size to be in percentages and this value would be translated to the percentage of the font-size
 given by the browser. Now the default font-size of browser, if the user doesn't change anything, is 16px.
 Learn: So if we put 100% for root font-size, that means the root font-size would be 16px IF the user doesn't change anything.
  and if user does change the default font-size, for example to 18px, then the root font-size would be 18px and ...
 Remember: WE WANTED OUR ROOT font-size TO BE 10px so 1rem would be 10px and ... . But the default font-size of browser is 16px.
 So we have to divide what we want. So 10/16 = 62.5%.
 So now imagine, if the root font-size is 16, so 16*0.625 = 10 and if root font-size is 20px, root font-size would be 12.5px.
 rems are not supported below IE9. */
/* Whenever we CAN use inheritance, we shouldn't use it in universal selector so we must use it in body selector and after this
in * selector we set the value to inherit. For example : box-sizing property itself is not inherited.But by setting box-sizing property on
each and every element on entire page to inherit (by setting box-sizing:inherit on * selector), it will automatically inherit whatever
we put in body selector.
Also remember it's better to use * selector instead of * to *,*::after, *::before (also selecting all of the after pseudo elements
and before psuedo elements too!). If we don't select those pseudo elements too, just the real elements (elements that are not
after or before pseudo element) would be get those properties, but if we also select those pseudo elements, they would get those properties
too.*/
/* Website rendering phase:
 The css visual formatting model is an algorithm that calculates boxes and determines the layout of these boxes for each element
 in the render tree, in order to determine the final layout of the page.
 The algorithm looks at:
  dimensions of boxes, which are calculated by the box model
  the box type which can be inline, block or inline-block
  the positioning scheme, which includes concepts like float and absolute and relative position
  stacking context
  other elements that are present in the render tree
  external information like current viewport size, dimension of images or ...
  SO by putting all of these factors together, the browser figures out how the final website will look for the user.

  Fill area: Remember how text content and images go inside the content of box model? The same actually does NOT apply for
  background images or background color of the box.So these properties will be applied not to the content of box model, but to
  the entire fill area, which includes content+padding+border but not the margin.

  Height and width in default box model:
  We can specify the height and width of an element, now if you choose not to specify the height or width of a certain element,
  the visual formatting model will just use the content of the box to determine it's size.
  How default box model calculate height and width of block level boxes?
  total width = right border + right padding + specified width + left padding + left border
  total height = ...

  Ex) If we define the height of an element to 100, and padding : 20, final height would be 140. But this isn't good!!
  So whenever we define width or height of a box, the padding and the border get added to what we defined.
  Solution is box-sizing: border-box; so with this, the height and the width will be defined for entire box including the padding
  and the border and not just for the content area. So the formul will becomes:
  total width = specified width
  total height = specified height

  So now if we define some padding or borders, they won't get added to the diemensions of the box.
  <li> and <table> also produce block level elements.
  Block level:
  Usually occupy 100% of it's parent's width and create line break after and before itself meaning that they are formatted verically one
  after another and the box model for them work as mentioned before (those 2 formulas...!)
  These elements have: display:block or display: flex or display: list-item display:table.
  ---------------
  Inline elements:
  They only occupies that their content needs so they don't cause line breaks at all.But instead they just sit inside their block-level
  parent element.But the box model works different in inline elements.
  Important: First: The height and width property do not apply on these elements.Which means we can't use these properties here.
   Second: We can only specify horizontal paddings and margin on inline elements.
  Recap:
  Content is distributed in lines
  Occupies only content's space
  No line breaks
  No height and width
  Padding and margin only horizontal(left and right)

  So they have limitations, in order to overcome that we use inline-block elements.
  --------------
  Inline-block elements:
  They technically are inline boxes but which simply work as a block-level box on the inside.So since they are technically inline
  elements they use only their content and cause line-breaks.But since they work as block level elements on the inside, the box
  model apply to them just like in the regular way.
 */
/* Positioning schemes:
 default or position:relative:
 If you use position relative on an element, it is still in the normal flow and normal flow means that the elements are laid out
 on the page in order of code.
 ---------------------
 Floats:
 The float cause an element to be completely taken out of normal flow and shifted to left or right as far as possible.Until it touches
 the edge of it's containing box or until the edge of another floated element.When this happens, text and inline elements will
 wrap around the floated element. Also when an element is floated, it's container WON'T adjust it's height to the floated element.
 The usual sulotion is to use clearfix
 ---------------------
 Absolute position :
 Just like floats, when you set position to absolute or fixed, the element is taken out of normal flow.But the difference between
 float and absolute is that in absolute, the element has no impact on surraounding content or elements at all.Even it can overlap them.
 Important: We use top, ... to offset the absolute positioned element to it's relatively positioned container.

 z-index creates a new stacking context.
 Each element use the z-index property on an either relatively or absolutely positioned element and that's one way of creating a new
 stacking context.
 Not only z-index creates stacking context, an opacity value different than 1, a transform property or a filter or ... also creates
 new stacking context.That's why even with the z-index set on a positioned element, the stacking order doesn't work as expected.
 */
/* BEM: block element modifier : block__element--modifier
 In BEM, block is a standalone component that is meaningful on it's own.
 An element is part of a block and has no meaning on it's own.
 A modifier is a flag that we can put on a block or an element in order to make it different from the regular blocks or elements, to
 make a different version.

 7-1 pattern: Means we have seven different folders where we put partial Sass files and then one main Sass file which in there, we
 import all of our partial into one final compiled css stylesheet.
 7 folders are:
 base: Where we put the basic definitions
 components: In this folder, we have one file for each component
 layout: Where we define the overall layout of the project
 pages: Where we have styles for specific pages of the project.
 themes: If you want to implement different visual themes
 abstracts: Where we put code that doesn't output any CSS. Such as variables or mixins
 vendors: Where all third party CSS goes there.*/
/* -Functions in SASS are similar to mixins with the difference that they produce a value that can be used later.
 -extends: Make different selectors inherit declarations that are common to all of them.
 -control directives: For writing complex code using conditionals and loops

 SASS syntax is indentation sensitive and doesn't use any curly braces and semicolons and it is more confusing.*/
/* & in SASS, writes the selector up until where it's currently used. */
/* If all of the childs of an element have floated, the height of that element becomes 0. So we must add .clearfix class
to that element.
The clearfix class adds a pseudo element after the collapsed element. So we decalre this class as : .clearfix::after
So this pseudo element will clear the float.
.clearfix::after {
   content: "";
   clear:both;
   display:table;
} 
*/
/* In sass, mixins are like huge variables for storing some reusable code. For calling them, we use : @include <name of mixin> */
/* For nesting a pseudo element inside an element selector in SCSS and inside that elementor selector we can say:
 &::<pseudo element> or for &:<pseudo class>
 darken function in sass: darken(<color>, <how much darker in percentages?>) and also we have lighten() function.
 For writing your own function, you can say:
 @function divide ($a, $b) {
    @return $a / $b;
 }   
 and for calling the function, we just use it's name and (). For example: margin: divide(60, 2) * 1px;
   */
/* What is extends in SASS? By using them, we can write a placeholder and put a bunch of styles there and then other selectors
extend that placeholder. For example the properties that are common between the <button>s , we can just put them in there.
We create a placeholder in sass like: %<name of placeholder>
EX) %btn-placeholder {
   <put the styles that would be duplicated if you don't use placeholders and extends>
}
and for using the placeholder or use those styles you can say: 
@extend %<name of placeholder> 

So we must use @extend when the selectors or the elements that you're extending, are actually pretty related to another.

But why we don't use @mixins instead of placeholders and just @include them? Because with @extend, the SELECTOR is copied to
where we defined the placeholder and not the code. But with @mixin, all of the code would be copied to where you @include
that @mixin.
For example:
 %btn-placeholder {
    <some style ...>
 }

 .btn-main {
    &:link {
       extend %btn-placeholder;
       ...
    }
 }

 So in the example, by using placeholder, the styles inside %btn-placeholder won't copy inside .btn-main, but .btn-main:link
 will copy instead of %btn-placeholder in compiled CSS code. But if we were used @mixin, all of the styles of 
 %btn-placeholder would copied into .btn-main:link .

*/
/* There are several ways to install SASS on local computer and there are several ways to do this. But the easiest one is to use
a npm package called node-sass .
The node-sass package compiles sass code. But the node sass is a develop dependency. It means basically node-sass is a tool
that we use to develop our project.
The first thing that we do in a new project, before installing packages is to create a package.json file which will contain 
the definitions of our project and where npm will write the packages that we use in project. So we say: npm init
Now let's install our sass compiler. So npm install node-sass --save-dev
--save-dev will make package.json file gets updated and lists this package as one of our developer dependencies.
What is developer dependencies? It means that node-sass is a tool(a helper) that we use to develop our project.

In older times, when you install a package as a dependency, it won't show in the package.json file until you specify an option which is
--save . Nowadays it doesn't necessary anymore.

We don't need to share the node_modules file with others. So if you want to share your project, you'll only share other things not the
node_modules folder. So you must share package.json file instead of node_modules directory. Because from package.json file, we can
recreate the node_modules folder. So if you don't have node_modules but the package.json currently, you can write: npm install .
For deleting a package in older days: npm uninstall <package> --save . We used --save because with this, it will remove it also from
package.json file.
For using node-sass package, you must use it with writing npm scripts and the script for compiling the scss code is:
"compile:sass": "node-sass <input file(location of the scss file-relative to package.json file)> <compiled(output) file which is a css file>"
If you have any css file in that outputted location with that name, when you run the command, it would overwrite it.
But wait! Why we can't write this exact command in terminal for compiling sass? Instead we use terminal to just say npm run <name of
the npm script>? In other words, why write our npm script in package.json and then we need to CALL that script with it's name from the
terminal? and not write the exact command in terminal and then hit enter to actually run that command? Because that's not going to work!

For keep watching the main scss file, we can add -w flag to the end of our currently npm script, so it would be:
"compile:sass": "node-sass sass/main.scss css/style.css -w" So with this file watcher, when you change your code, it will automatically
compile the sass code to css.
Now we need to have another stuff, so each time we change the code, the browser would be reloaded automatically.
For this task, we must install live-server package as a dev dependency and globally. So instead of using --save or --save-dev , we use
-g . Now because we didn't specify --save-dev (--save is not required anymore these days), this newly installed package won't be in
package.json file and you'll probably will see that this package is not in node_modules directory.Because we installed that package as a
global package and since it's a global package we can call this package DIRECTLY from the terminal.

By running live-server we would have a real http server(protocol) (we have also file protocol in general.)

So now for running the local http server and the node-sass package, we must let those 2 tabs or terminal open.
*/
/* In regular CSS, we can't put a hexadecimal color(like #fff) in a rgba function and then put opacity and then it would translate
the color. No! That won't work in regular CSS. But in SASS it will work! So in regular css you must say: rgba(x,y,z, opacity) not
rgba(#xxx, opacity) but in sass or scss you can do this.
So remember: Using hexadecimal colors in rgba() only works for scss or sass. So in regular css, we have to define the colors separately
for R G and B with a number in range of 0 to 255.*/
/* For nesting the selectors, remember we had BEM methodology and till now, all of our selectors are really just ONE CLASS FOR EVERY
element. So they all, have a same specificity which is extremely low (they have just one class). Also since each and every element has a
class, nesting can be a bit difficult here.So it's looks like there's not much to nest here with these classes. But maybe still we can
do some nesting.

In sass, & operator copies the parent selector where we are do nesting in that parent selector. For example:
.header {
...

&__logo-box {

}
}
In tbe example above, the value of & is .header (not header!).*/
/* 7-1 pattern: With this pattern we create 7 folders and one main sass file to import them all the files that are in those folders.
All of those 7 folders are going to be in the sass folder.
In base folder, we're going to put the basic project definitions. So like a project's boiler plate. In the base sass file, we have
real low level basics.Such as resets and styles for <html> and <body> element selectors. Note: This file should be a partial, so we can
later import this file into the main.scss file.
Learn: The partial files always start with an underscore. So if you name a scss file starting with an underscore, that file would be a partial
 scss file. But when you're specifying the path to the file when importing the partial file in main.scss , you don't need to write
 the underscore and the extension for the name of the file. So for example: @import 'base/base'

In abstracts folder we're only going to put code which is not going to output any css.Like variables, mixins and functions.
In components folder we're going to create one file for each of our components.
In layout folder we're going to have a global header, footer and ... . Basically the layout is what holds our components together.
If you have very specific styles for a specific page like for homepage, we can create a new file for that specific page in pages folder.
In vendors folder we put 3rd party css. Like the css file for bootstrap or icon system or animation framework.

Remember: In the end in the main.scss, only serves the @import s of all other partial files. So there will ne no code in this file,
except @import declarations.

Everything that has font-family line-height and ... (related to typography) should go to _typography file.
 */
/* 3 basic principles of responsive design:
1) Use fluid grids and layouts: We must use percentages rather than px s for all layout related length (specially do this for
width properties). Why we do this? Because we want to allow the content to easily adapt to the current view port.

2) Flexible/responsive images: Images behave differently than text content (because they don't scale automatically as we change
the viewport) and so we need to ensure that they also adapt nicely to the current view port.
Usually we make images flexible by defining their dimensions in percentages rather than pxs (fixed units).
Images usually make up the biggest part of pur website's size, so we need to optimize images for different width.

3) Learn: Media queries: Allow us to change styles on certain viewport widths, which are called breakpoints. Basically media queries allow us
    developers to create different versions of a website for different types of devices.

3 main ways of laying out a web page: 1) float-based layouts. 2) Flex-boxes which are for laying out elements in 1 DIMENSIONAL row.
3) CSS grid is perfect for creating the overall layout of the page in a fully-fledged 2 dimensional grid.
*/
/* Building a custom grid with floats (fluid grid):
What is a grid? It's a design system.
The consistent space between each column is called gutter.
The columns should be always be in a container and that container is called a row. No matter you have 3 columns or 4 columns or ...
all of these columns should be inside a container called row.So let's say that all of the columns that are in one line, are actually
in one ROW. All of the excercises are in test-grid section.
After writing the html code for this exercise, we must create a new scss file to build this grid which is a layout, we must create a
new scss partial file in layout folder and call it _grid.scss and then import this new file in main.scss .
*/
/* In native css, in calc() we can mix units. But in preprocessors we can't do mathmatical operations with multiple units and it's
actually pretty logical why it is that way. Because we COMPILE the sass files while we're developing the page, so even before the
page is served to the user. But this kind of calculation depends on layout. So it has to happen when the website is rendered using the
visual formatting model. So that's when these calculations can occur. Because it's only after that when css and the browser know what
a percentage is and what a rem is and ... . So for layout calculations we must do those calcs using native css.*/
/* In border-radius: <value-1> <value-2> the first value applies to top-left corner and second value is applied to bottom-right corner of
element.
In padding: <value-1> <value-2> value-1 is for top and bottom and value-2 is for right and left.*/
/* In chrome dev tools in top-right side of elements section, you can see :hov . This is useful when you want to force a state of
 an element to see the styles that apply to that element when we hover on it.*/
/*
    Important:
     Now after giving a width to this .cta, the button gets out of centered place! So we can use text-align: center; on the
     container of btn which is .cta . Because text-align: center affects on inline and also inline-block elements.
     Even though the property says “text” align, it affects all elements inside the block-level element that are either inline or
     inline-block elements. The property only affects the content inside the element to which it is applied, and not the element itself.
     To center the element itself, the margin property can be used.
     To center inline or inline-block using text-align: center; (HORIZONTALLY) you must place the <img> inside of a BLOCK-level element such
     as a div . Since the text-align property only applies to block-level elements, you place text-align: center; on the
     wrapping block-level element to achieve a horizontally centered <img> or any inline or inline-block element. */
/* When you have an image that is all the way to the edges of a box and we make that box to have border-radius, although we specify a
 border-radius, the edges of that box is still sharp. So as I mentioned we can use overflow: hidden; on parent of that image.
 Now if you use clip-path property on that image, so clip-path in google chrome breaks overflow that we set for that image.
 Remember: We set overflow: hidden; on parent of image, so the corners that are overflowing the parent element would be hidden. BUT
 for some reason when we use the clip-path property on that image which causes overflowing, then the overflow: hidden; no longer
 works.
 The solution is to set the corrupted borders manually. So in &__picture we can say:
 border-top-left-radius: 0.3rem;
 border-top-right-radius: 0.3rem;*/
/* Learn: Block elements automatically (and if they aren't already wiped out of normal flow), gets 100% width of their parents,
    but for this .story element, we don't want it to get's 100% width of it's parent automatically so we gave it a width.
    If you don't specify a width for a block element AND if that block element doesn't already wiped out of normal flow,
    the width of that block element is 100%.
    Now when you already centered a block element inside another block element, if you give this block element any other
    width than 100% it won't be no longer centered.
    So we can use margin: 0 auto; on element that we want to center it horizontally and that element will be CENTERED ITSELF!
    This approach(margin: 0 auto;) won't center the children that are inside this block element.
    For making the content that is inside block element to center:
    1)
    Set the child elements to either display:inline or display:inline-block, then set the parent container to text-align:center,
    the children will center in the parent- depending on whatever its width
    2)
    If the child content is block level (display:block) set text:align:center; on the parent, then give the child margin:0 auto
    and a width less than that of the parent*/
/* 16. Building the Booking Section - Part 1:
1) How to implement sth called "solid-color gradients"
2) How the general and adjacent sibling selectors work and why we need them?
3) How to use the ::input-placeholder pseudo element
4) How and when to use :focus, :invalid , :placeholder-shown and :checked pseudo classes?
5) Techniques to build custom radio buttons

Important: When you have set the position of an element to absolute and therefore you need to specify the reference of this
 absolute positioned element by specifying the position of reference of it, you don't need to give that reference a relative
 position! The absolute position of reference would do the work and therefore if the parent would have the position of absolute, it
 would be the reference of that element with position absolute. BUT! Now the parent needs to have a reference with having
 position relative or position absolute. So every position: absolute element needs to have a reference which that reference
 must has position: absolute; or position: relative; . But if the reference has position: absolute; then ITSELF needs to have
 a reference with absolute or relative position and ... .So if you set the position of reference to relative, then it doesn't need
 a reference anymore.

 Learn: For centring something both vertically and horizontally, you need to give it:
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

So we need a reference for it, which that reference must be positioned.(absolute or relative doesn't matter. If you give it
absolute, we need to specify a reference for that reference too which must be positioned as well.)

 Property           | occupies space | consumes clicks |
+--------------------+----------------+-----------------+
| opacity: 0         |        ✓       |        ✓        |
+--------------------+----------------+-----------------+
| visibility: hidden |        ✓       |        ✗        |
+--------------------+----------------+-----------------+
| display: none      |        ✗       |        ✗        |
*/
/* Learn: Inline elements can be centered horizontally by saying text-align: center; on their parent. Because an inline element,
     behaves just like a text.
When using emmet: <element>.<class-1>.<class-2> will create an element with class attr of: class="class-1 class-2"*/
/* 20. Building the Navigation - Part 1:
- What is the "checkbox hack" and how it works?(Actually our navigation is working with this hack!)
- How to create custom animation timing functions, using cubic bezier curves
- How to animate "solid-color gradients(to create nice hover effects in this case)"
- How and why use transform-origin

As I mentioned, what makes the entire of our navigation and especially the clicks(when we click and navigation opens) work, is so called
checkbox hack. How that works?
Remember we had custom checkboxes in our form? What we had there, was a radio button(<input type="radio">) connected to a <label> and
when we clicked on that <label>, then that radio button would become selected(also by clicking the radio button itself, it would be
checked). And that's the same thing that we're gonna do, but except the radio button, we're gonna use a checkbox.

So like in the form, we make 2 <input type="radio"> hidden and if their labels which were connected to those hidden radio buttons,
were selected, because of their connectivity, that radio button was selected actually. So the actual input was hidden but it's connected
label was shown and INSIDE those <label>s, we created a circle which was a <span> and it looks like a radio button and also the actual text
of that label.
Why inside of labels we created those circles and text?
Because that <label> and whatever is inside of that <label> are connected to radio button, so I put them INSIDE of that <label>.

The 3 steps for this to work is:
First to have a checkbox which we will make it hidden later.

Second we must have a label connected to that checkbox(<input type="checkbox">) which that <label> is where we click and
that <label> would be the button for opening that nav menu.

The third step is to reveal the entire navigation which is in the background, as soon as the checkbox(<input type="checkbox">) becomes
checked and for that we can use the :checked pseudo class.

So first put the HTML code for that navigation, on top of everything else in <body>. So that navigation would be the first element
in our entire web document.

Now for checkbox hack, first we created an <input type="checkbox"> and give it an id to connect it to it's <label>.
Then create it's label which we created it after the <input> itself.
Important: And we know that in checkbox hack, we need to hide the <input type="checkbox"> itself and instead it's <label> which is
 connected to that checkbox, would be a kind of button which we can click on that <label> to check that checkbox and that's exactly
 what we did in radio button hack, which in that case, the <input type="radio"> was hidden and instead we click on the label of that
 radio input and make it selected.

Learn: When we have li.navigation__item>a.navigation__link in emmet:
 it means INSIDE of li with class of navigation__item, we would have <a> element with class of navigation__link.
 So in emmet, a>b means directly INSIDE of the a element, we create the b element. */
/* 21. Building the Navigation - Part 2:
Now we need to make the navigation works, as soon as we hit the navigation button. First of all we need to hide the
.navigation__background and also hide the .navigation__nav. So I commented out transform: scale(80); in &__background.

For checkbox hack in this case, we have navigation__checkbox , navigation__button(or our <label>) and navigation__background.
In this hack, we click on the <label> and the checkbox becomes checked and then after the checkbox is checked, we want the
navigation__background to become visible. So how we translate that into a css selector?
We use :checked on the <input type="checkbox"> class, just like what we did in radio button hack and then we use the sibling
selector or ~(but not the adjacent sibling selector) to select .navigation__background which is not the adjacent sibling of
.navigation__checkbox. So we didn't use direct or adjacent sibling of .navigation__checkbox which that adjacent sibling of it
is .navi-toggle but we don't want to select that, but we just want to select a normal sibling of .navigation__checkbox ,
so we used ~ selector.

Now for increasing the size of navigation__background , we use scale() function on it. But remember, you can not make sth visible
by using scale() if that element wasn't visible in the beginning. You can just make it bigger by using scale().
Now also if you again click on the .navigation__button, the checkbox becomes unchecked and therefore the styles that we have
inside of &:checked ~ .navigation__background would be removed and therefore the .navigation__background would again go
under the .navigation__button and won't be visible to us.
We COULD nest this selector in the &__checkbox but I prefer to write it out of &__checkbox , because it was done in a
separate video.
Now let's make the .navigation__nav visible after the &__checkbox is in checked state, by setting it's opacity:1; and
width to 100%(it was 0 before.)

Now we need to animate those 2(I mean when .navigation__background gets bigger and when the .navigation__nav gets visible).
So let's add transition prop in normal state of .navigation__background and .navigation__nav and in .navigation__nav we just
want to animate the opacity and therefore the width transition should be instantaneous because we didn't specify it in
transition prop. So the width transition from 0% to 100% would be instantaneous. But now, you see the .navigation__nav goes
to the right side during the .8 transition of :checked state to normal state. So we actually need to animate the width too.
So let's change the opacity in transition prop of .navigation__nav to all.
But after that, now you see that the list items weirdly moving in, from right side and also moving out to right side again,
when we uncheck and we don't want that to happen. By doing that, we also get rid of a tiny white background that we had on
one of our list items(04 stories one) during the animation.
That's because we didn't specify the width for .navigation__list . So if we set it's width to 100%, then that weird moving
from right and moving out to right shouldn't happenning. So go to .navigation__list and add width prop 100%.
Now if you see that, the latter problem solved but the first one not. Because remember, when we close the .navigation__background
and .navigation__nav , the entire container there, reduces it's width from 100% to 0, so everything kinda collapse all way
until to 0 and since we fix that .navigation__background to the right side by saying: right: 0; , then it moves to the
right side.

Now, I want a custom transition time and function for .navigation__background and .navigation__nav transition props.
There are some built-in transition timing functions like ease-in and ... but this time we want to use a custom one and for that,
we use sth called cubic-bezier functions and in cubic-bezier() we have to put 4 numbers which define the cubic-bezier curve.
But since we don't know which numbers to put, we can use easing.net and cubic-bezier.com .

Learn: Easing function is basically a function that specifies how much change occurs, over time. For example start slow and
 then accelerated and then slow down again. We used easeInOutQuint.
For .navigation__nav , let's use easeInOutBounce. So let's use it's numbers and copy them from that website to our code.
Now you see that the .navigation__nav actually moved a bit to other side(left-because it was coming from right side to the
left and then it goes a little bit again to right side) and then goes to it's specified location.
That's because when we are in transition from normal state of .navigation__checkbox to checked state of it, we are going from
width: 0; of it in normal state to 100% of width, but the 100% even gets a bit larger maybe 110% so it goes to 110% width,
because of the type of function we used in cubic-bezier, which was easeInOutBounce and in that curve, it comes out even from
the final step. So if we assume the final step as 1, it goes to 1.3 . In other words, that curve contains some values out of
range. */
/* 22. Building the Navigation - Part 3:
The icon that you see in navigation__button, is composed of 3 lines. The line in the middle is simply a small <span> and the
upper one would be a ::before pseudo element and the bottom one would be ::after pseudo element. So instead of putting 3
same elements in the html, we just put 1 and then use pseudo elements to make the rest.
Then when we click on the .navigation__button , you see that the middle line disappears and the other ones rotate, in order to
form the multiply or cancel sign.
So go to <label for="navi-toggle" class="navigation__button"> and create .navigation__icon and that <span> would be empty, so
let's put &nbsp;
There are also some styles that those 3 elements(::before, span itself and ::after) share between each other.

Now we want when we hover over <label for="navi-toggle" class="navigation__button">, ::after and ::before of
<span class="navigation__icon">, move a little bit up and down respectively.
For doing that, first we need to select the hover state of .navigation__button and then because the .navigation__icon is inside
of .navigation__button and also the ::before and ::after of .navigation__icon are also inside of that &__button, so
we can select those ::before and ::after by saying: .navigation__button:hover .navigation__icon::before {} and ... .

Remember: We knew that in css, when you select like: <a> <b> {} it means the <b> is child of <a> (direct or indirect).
Also we need to animate the top prop of those ::before and ::after , so we have to set transition prop on normal state of them.

Also you could use translate() functions to do those things(when we hover on &__button , the lines must go up and down) instead
of using absolute positioning and top prop.

Now we must make the ::after and ::before of that <span class="navigation__icon"> , to make a cross and the middle line to
disappear, when we hover over :checked state of <input type="checkbox">.*/
/* Important:
    descendant selector (space)
    direct child selector (>)
    adjacent sibling selector (+)
    general sibling selector (~)
 */
/* 23) Building a pure CSS popup - Part 1
- How to build a nice popup with only css?(This time we don't use checkbox hack for that functionality(which you could use
it, but instead we'll use the :target pseudo class))
- How to use the :target pseudo class?
- How to create boxes with equal height by using display: table-cell; ? (Remember my long problem when I had some columns that
sit next to each other but I wanted them to have equal height to the tallest column and I solve that problem badly be setting
fixed height on the parent and childes must have that height too by using height: 100%; and ... .)
- Some tools for text formatting like creating column layouts and automatic hyphenation of words using new hyphens prop.
- How to create css text columns?
-How to automatically hyphenate words using hyphens?

When the popup opens, the background becomes dark and we saw that the popup box itself came in with a nice animation and all of
that dark background and the popup box are on top of entire web page, so even on top of navigation__button which has a z-index
and the popup and the dark background behind it, are fixed position. Therefore if you scroll up or down, the popup and it's
background stays in the same place.
So we have an element which covers the entire viewport and there we have the popup itself.

You can put the html code of popup and it's background where ever you want, because they are not really tied to any of
sections of our site or any other html of our site. So let's put it at the end of everything in markup, even after the footer.

In the popup, we have 2 boxes side by side which they have the same height. In the right box, the content is vertically centered based on
it's container(right box) or based on the other table-cell basically, because those 2 elements side by side, have the same height
and also it's also centered vertically based on the left box too. Because the height of right and left boxes are same.

So how make 2 boxes side by side having automatically the same height.

For making those 2 <div>s side by side, we can use float. So float: left; for the element in the left and right for the element in
right. Also you could give them both float: right; or float: left; because TOGETHER they make 100% of the width.
Now the problem with this approach is that in this case, the left element has the entire height of it's parent but the right one
only has the height that it needs and not more. It's a normal behavior.

Now what we want is that those 2 boxes have the same height, because if they have a same height, it's easier to center the content of
the shorter box(the box that has a shorter height) vertically in it's parent.

So instead of using floats, we're gonna simulate a table. So let's set the display prop of &__left and &__right to table-cell and then
their parent element which is &__content should have display: table;
Important: Now with that, the browser will automatically give the children which have display: table-cell; , a same height.

Now all there's left to do is to use a prop that we can use on all display: table-cell; elements which that prop is vertical-align and
we set it to middle and we give it to the box that we want to make it vertically centered which that box is definitely the shorter one
because the taller one don't need to vertically centered, because well, it is occupying the entire height of those 2 boxes.

Important: The height of both are STILL same as the height they actually occupy and demand even with all of that table and table-cell and ...,
 so technically they still do not have a same height but by using table-cell on both of them, the shorter one gets some padding which that
 padding make that element to has the same height with the other one, by help of the automatic given padding by browser.

In that technique, you see the shorter one which has a shorter height, got some padding in order to make it kinda same height of
the taller one, but that padding is not showing up in box-model of dev tools, neither it is not the real height of that element.
So basically they are not the same height, but the technique gets the job done.
So we are faking that we have a table there. Because if it was a real table, we would have to use the proper html elements for that but by
using display: table and ... we are basically faking and saying that this is a table.

Now the image that we have on edges of our <div class="popup__left">, overlap the border-radius
that we gave to that <div class="popup__left">.
Learn: So when an image is overlapping the border and therefore the border-radius of that box isn't showing where the image is overlapping,
 we give overflow: hidden; on the element that has border-radius. Now the parts of image which are overflowing that box with border-radius,
 will not be visible anymore because of overflow: hidden; .
So let's give &__content overflow: hidden;

Now I want to separate my text into 2 different columns inside the .popup__text and also the Automatic hyphenation for that element.
Automatic hyphenation means when all of the characters of a word can't fit in one line, css would place a hyphen at the end of the
line and write remaining characters of that word in the next line. So you have a word but there's not enough space for it and therefore
css would put a hyphen and that word continues on the next line and Important: if you select that word, it gets selected on the 2 lines
not only one of those lines. It doesn't matter you select it from the next line or the first line that the word begins.

First let's start with the text columns. Column layout is sth very new in css.
For make it work. all we have to do is to specify prop called column-count on the element that has that text which you want to make it
column like. With that, it will automatically create x columns for us.
The column-gap is space BETWEEN the columns and the default for it is 1em.

column-rule is basically just like a border which will be exactly in the middle of those columns. So the browser will automatically put it
there.

CSS automatically balances the height of those columns no matter how many of them are there. So you may see when we have column-count: 3;
the first and second columns they have the same height because thy still have enough text(there is some remaining text to go to third column
so therefore, the first and second column have the same height).

For hyphenation, you give hyphens prop to the element that has the text you want to hyphenate it. The 3 possible values are:
none(default value), manual which is not really useful because if we say manual, then we can go to our text and manually specify where
we want hyphens to occur.
So the only thing that is useful for hyphens prop is auto. So it will automatically figure out where to place the hyphens.
Now in order for this to works correctly, you actually have to define the document language in the <html> element, you must put the
lang attr and set it to en or your language.

The hyphenation changes when the width of viewport changes. So it's kinda responsive.
Important: The hyphens prop needs a lot of prefixes in order to make it work in all of the modern browsers. Because in older versions of
 browsers, that prop won't work. So ON TOP OF the actual prop, give
 the prefixed versions of that prop.
 -ms- is for microsoft edge.
 -webkit- is for chrome and safari.
 Also we need to do this for column-count and it's relative props too.

There's a tool named autoprefixer for doing these things. So usually you shouldn't add the prefixes yourself manually.

Now we need to handle the open and closing functionality of popup. */
/* 24. Building a Pure CSS Popup - Part 2:
Now let's take care of functionality of popup. The way that we're going to make that to work, is by taking advantage of sth that
exists in html, which is called anchors. How anchors work?
Imagine on <section class="section-tours"> , we put an id and maybe call it again, section-tours (the name doesn't matter and
it can be the same as class) and we know that ids are unique. Now if we go somewhere else on our document on an
<a> element that we have in our header and in href attr of that button we put: #<the id name of the other
element>, so in this case it would be: #section-tours . Now if you click on that <a> element, the page goes to that
element which has that id and also in the url, you see /#<id> was added.
So now, that section which has that id is an anchor or in other words we can say that <section> is the target of that
<a href="#<the id of that target>">

Remember: When an element has display: none; we can't animate it over time. So if you want an element to be hide in the
beginning and also be able to animate it, we can set it's opacity to 0, instead of using display: none; which we can't
animate it. Because the value of display: none; which is none can't be animated, because, well, it isn't a number which
be able to increased or decreased over time in an animation, so we must use sth else which can accept a number for it's value
in order to animate it, therefore we used opacity: 0; to hide the element and also be able to animate it. But we also need
to use visibility: hidden; with opacity: 0; because if we ONLY use opacity:0; , then the text an content and elements will
still be there but we can't see them. But we don't want that. We want the popup to be completely hidden.

Now how we actually make the popup visible?
We can use the anchor and the target. So first in the html, let's make the <a>Book now!</a> elements to be a
real! anchor tag by giving it the id of target, so we gave it #popup. So that is the button which should show our popup
when we click on it. Then give the element which should be a target element, it's id. So we gave it to <div class="popup">.
Important: When we click on a real anchor element, we go to where the target element sits and also that target element can
have a :target pseudo class when it becomes a target, so when the url changes to having #<id of target element> in it.
Now when we click on the anchor element which has id of #popup, we go to the target and THAT TARGET IN THIS CASE IS THAT
<div class="popup">and also we must make that popup visible with an animation which happens over time.
TODO till 4:00*/

/* 2. Mobile-First vs Desktop-First and Breakpoints:
2 fundamental aspects of modern responsive design are deciding about doing mobile-first or desktop-first for website or app, as well as
selecting breakpoints for our project, when writing media queries.
Responsive design strategies:
In the desktop-first approach, we optimize our interfaces for large screens and therefore we start by writing css code for these large
screens in our CSS files. This is what we have been doing all the time in the Natours project. Now later when we make the website responsive,
we write media queries, in order to shrink the design to fit the smaller screens. This is the more traditional way fo doing things.
The way we do that is by writing media queries which test for max-width.

Recap: So in desktop first strategy, we START by writing css for large screens and THEN, we write media queries for smaller screens.

Mobile first strategy, we START writing css code for smaller screens in order to optimize website for mobile and THEN move up to large
screens from there, using media queries and in this approach, we do that by writing media queries which test for min-width instead of
max-width .
The philosophy behind this strategy is that the designers really have to think about the mobile experience, by reducing our websites or
apps to absolute essentials and therefore we must strap away everything that's not really necessary for mobiles and smaller screens, in
order to end up with a smaller and faster final product.

The differences between the type of media queries that we have to write for desktop approach(with max-width) and mobile approach(min-width):
As an example, we have a pixel spectrum, going from 0 to infinity, with a couple of breakpoints:
----------------------------------------------------->infinity
0px       600px      900px     1200px           |
                                                |
                                             Our initial desktop-first code goes here. So our initial code is on the right side of spectrum.

max-width: 600px or is width <= 600px ? .A media query with testing max-width, checks if the current viewport width is smaller or equal to
600px and if it is, then all the CSS code which is in this media query will apply and if not, that specific code in that media query won't
apply.
So in a media query with checking max-width: 600px; , 600px is the maximum width which at that width, the media query STILL works and it still
applies it's code and after that maximum point, it stops working and applying it's code.

Important: In these media queries, we just override specific parts of the global css code(only the parts that we want to change, because
 all of the rest of the global css code will of course still apply).
 So think of media queries as tools to overriding specific parts of our css, for specific viewport width.

Now the same works for the next breakpoint(media query), for example 900px. So with that breakpoint, all of the code that is in this
media query will work as long as the width is less or equal to 900. In other words, as long as the maximum width is 900px.
But maybe now you are wondering, what if an element has a width of 500px? Which media query will apply?
The codes of both media queries will apply. Because both conditions(max-width: 500px, max-width: 900px) are true, RIGHT?
Important: Now, if you have conflicting css rules in those media queries (which is usually the case), like defining the global font-size
 in both media queries, then the one which appears LAST in the code is the one that takes precedence(because of cascade).WHY?
 Because media queries don't add any importance or specifity to our selectors.
 SO THE ORDER OF CODE MATTERS A LOT AND THAT'S WHY WE KEEP MEDIA QUERIES ALWAYS AT THE END.

Above 1200px, we have the desktop version of our project, which in slides, is outside of any media queries.
-----------
In mobile-first approach, our initial css code(the code other than our media queries- or the code we wrote at first, because at first we usually
don't write any media queries, RIGHT?) is obviously on the left side of px spectrum, where the mobile screens exist.
So where before we had max-width media queries(in the desktop-first), now, we have min-width based media queries.
So before, we had max-width: 600px base media query, now we have min-width: 600px; media query, which basically asks the question:
Is the current viewport width LARGER than or equal to 600px?
If it is, then the code in that media query which tests min-width: 600px , applies. So it's called min-width media query, because 600px
is the minimum width which at that point, the media query starts to apply till the next bigger min-width media query.
Now visually speaking about the last example, that example(which is a media query with min-width of 600px) translates to a
pixel range(not the pixel spectrum itself-because the pixel spectrum starts from 0px in both approaches obviously!) which
starts from 600px, covering all the way until infinity.
So all screens with the width larger than 600px, will have the code in this media query applied to the page.

So we have to use that type of media query in the mobile-first approach, because basically we want the queries to stay away from our
smallest screen styles. So we want them to work for bigger screens, therefore the max-width approach that we had before doesn't work
in this case. Because max-width kinda block the styles when the screen arrives to a certain width which is that max-width point. But in
mobile-first approach we don't have that philosophy.
Because in mobile-first approach, we start from the smallest width and then go to larger screens, by setting breakpoints which those
breakpoints check if we have the min-width of the screens of that district. So we must use min-width in those media queries and we must
start from small screens.

So we saw that the whole strategy behind mobile-first, is to narrow our interfaces being it websites or apps, to the bare minimum, in order
to create small, fast and efficient product, completely optimized for MOBILE users. Because a huge amount of internet traffic is coming
from mobile devices.

Another advantage of mobile-first is having all these design constraints on small screens, therefore we automatically prioritize content over
purely aesthetic design, which also makes sense. Because "content is king".

Is mobile-first approach suits for your project?
pros:
-100% optimized for mobile experience
-Reduces websites and apps to the absolute essentials
-Results in smaller, faster and more efficient products
-Prioritizes content over aesthetic design, which maybe desirable

cons:
-The desktop version might feel overly empty and simplestic (I mean why having an advanced system like a huge desktop computer, if
websites don't even use the device's resources and capabilities, right?. Also if you're used to to see a whole lot of desktop websites,
then it might seem a bit weird to develop mobile first. That's simply because a larger canvas(our monitor), where we can start designing
without so many restrictions, will give you much more creative freedom, which is great to set your websites apart from the competition.)
-More difficult and counterintuitive to develop
-Less creative freedom, making it more difficult to create distinctive products
-Clients are used to see a desktop version of the site as a prototype
- Do your users even use the mobile internet? What's the purpose of your website. So users of a website in a certain business niche,
might not even use the mobile that much for checking your website.

No matter what you do, always keep both desktop and mobile in mind. You should never design only for one of the solutions and just
leave the other one as a afterthought.

In our project, we're using desktop-first approach. So the media queries that we're gonna write are all max-width based.

Selecting our breakpoints: the options:
Important: The breakpoints are the viewport width which at that point, we want our design to change. Or in other words, at those points,
 we want to put(apply) our media queries, no matter what we decided about going mobile-first or desktop-first, one thing that is for sure,
 is that we have to select breakpoints for our design and there are 3 major ways of doing that:
1) The bad way: This way of choosing breakpoints, consist of simply using the width of popular devices as the breakpoints and the apple
products are good for this. The problems for this approach are:
A) You're optimizing for one very specific device and ignoring all of the users of other devices
B) This strategy is not future proof at all. Because if apple decides to change resolutions on all their devices you must change your
media queries. So using specific devices as breakpoints, is completely against reusable and maintainbale code.


2) Good way: In this way, we look at all the most-used devices width on the entire internet and try to group them together in a logical
way and then pick our breakpoints from those grouped width points. But remember, still this way is not good, because it's not ideal to
use real devices to figure out breakpoints. But it's better than the first approach. Because we're using a lot of devices and we're also
using the most popular deice width. Plus, we're not setting breakpoints at one specific point for each breakpoint but between similar devices.
So for each breakpoint, we're considering a couple of devices.

3) Perfect way: In this way we ignore devices all together and ONLY look at your content and design. So ideally: You begin at one size either
mobile or desktop and then start increasing your screen width or decreasing that screen width for desktop-first approach.
Then as soon as the design breaks, you insert a new breakpoint.
So you put breakpoints, wherever your design STARTS TO LOOK WEIRD AND OUT OF PLACE and don't think about devices at all.
This approach is difficult, because without constraints of not having at least a couple of pre-defined(the width of devices) breakpoints,
it's hard to find the best ones and therefore we'll end up with really a lot of them! and that's why we're gonna use the second method.
In the second one, we start with the most-used screen size which we can get from an app called statCounter.

Important:
 Usually you need one breakpoint for phones, one for portrait tablets, one for landscape tablets and one for the desktop. There can be more
 but these are the basics.
 The phone ranging from 0-600px, portrait tablets from 600-900px, 900-1200px landscape tablets and desktop 1200-1800px and big desktops
 start from 1800px-...
The last one is not mandatory and it's just IF we want to give users with big desktop screens sth SPECIAL.
The real close example for respective widths are: iPhone8, iPad portrait and landscape and macbook pro 15inch and YEAH! it is TOTALLY ok
to call those iPhone and Iad and ... . So in fact, we CAN and SHOULD use these devices to TEST our responsive designs. What we SHOULD NOT
do though, is to just use their width as breakpoints. As I mentioned. */
/* 3. Let's Use the Power of Sass Mixins to Write Media Queries:
With our responsive breakpoints now defined, let's start to implement them in media queries. In this lecure:
1) How to use a powerful sass mixin to write all our media queries with only one mixin and in order to do that you must learn the 2).
2) How to use @content and @if sass directives
3) Taking advantage of chrome devtools for responsive design

The traditional way(beginner way!) of writing media queries, was to simply create another css file and in there, write a BIG media query and
in there like html{} body{} and then copy ALL of our component styles and paste them inside that HUGE media query and we would have one media
query per breakpoint.
But what if we could add the media query into each of our selectors? For example, imagine that we want to make our story component, responsive.
We could add the media query inside for example, {} of .story{} selector and if you go ahead and write some styles inside that @media which itself
is in {} of .story{} so it would be sth like:

.story {
  ...
  @media(...) {
    ...
  }

  ...
}

and then open up your compiled css file, you see sth like:

.story {
  ... (normal css without attention to be responsive)
  @media (...) {
    .story {
      ...(the responsived styles live here)
    }
  }
}

So in compiled styles, you have your media query inside that selector and then inside that media query, again you would have the
selector that you wrote that media query for that selector. So we're repeating the selector in that case and also in the example you can
see that the .story is repeating. But in scss, you don't need to repeat that selector which you're writing that media query inside it.
So in scss, when we place the @media query inside a selector, we're saying that we're writing that media query FOR that selector and that
@media query will apply those styles which are in it, FOR that selector(of course if you select some other classes in that media query which
is in selectorA, the styles of that media query will apply to those classes. Important: But remember, those classes would have the selectorA
somehow in them too. Because, well, this is scss, and if you say:
  <selectorB>{
  ...
    <selectorC> {
      ...
    }
  }
It will compiled to:
selectorB {

}

selectorB selectorC {

}
So as you can see, you can select other classes and ... in the media query for a class too.)
With this approach, we would have multiple media queries inside a selector in order to set breakpoints for that selector and apply
some styles to that selector when the condition of that media query is true, maybe there would hundreds of those media queries, but it's not
a big deal, because having hundreds of those small media queries or one big one is not really a problem.
Learn: So you understood that you can make scss selectors responsive, by putting media queries inside those selectors. Also don't forget
 that the breakpoints are certain numbers all over the project and we won't decide to pick a new breakpoint for a selector.

Now imagine you have to write @media (max-width: 600px){...} in all of the files and in all of the selectors inside those files and even
worse, imagine that some day you would decide to change your breakpoints, then you would have to go back and change all of those numbers.
So there's an even better of that. So when you write a mixin, when you @include it, it would basically paste the code that it has in the
place that it was included. */
/* 4. Writing media queries - base typography and layout:
Now that we have a media query manager, let's start using it. But before we do it, let's think about the order of the media quereis that
we wrote in _base.scss . Why the current order of them is right and not the other way around?
Imagine we have 700px for width of screen. In that case both first ones of media queries in that file will apply, but since the
both media queries apply, the last one would really apply and that's what we want. Because in that case, 900px(the smaller breakpoint) is
the one which is closer to 700px(in other words, the latter media query must be the one that is closest to smallest viewport width(we're
talking about max-width based media queries now!)). But the other way around, then at screen size of 700px, we would have a font-size
of 56%, which was actually only supposed to be used in the range between 900 and 1200px and this is wrong.
Important: All of these stuff, are related to desktop-first approach. If you were writing mobile-first approach it was completely
 other way around. So in that case, we have to start with the lower width media query and move up to larger ones. Because in that
 case you start by writing min-width media queries and at the end would have a max-width media query, so everything would be opposite.

The good order of writing the media queries is to first start with: base and typography, then moving on to more general layout, like
header, footer, navigation and ... and also the grid. Then the more specific page layout and then finally changing the styles of
components. So:

Important:
 Order of making website responsive:
 base + typography(the styles in _typography.scss file) then general layout(folder) + grid then page layout then components

Also remember that we don't need to change many things because the responsive overall font-size of our web page which is set in
_base.scss , takes care of the most changes that we want to make for making site responsive. So we just need some adjustments that we
need to do which are pretty minor.
So now, the first thing is to make typography responsive, so let's go to _typography file. Now when you're on toggle device toolbar
in chrome devtools, click on those 3 vertical dots(more icon) and then click the show media queries. Now you can see that the
56.25em range is the smallest viewport width of our media queries.
In this mode, you can easily see which one of your media queries is currently applying, so when a range becomes darker, it means
it is applying. Now when you click on a range, it will move the website to the breakpoint of that range.
Also remember that in show media queries mode in chrome devtools, the blue ranges are max-width based media queries and the
orange ranges, are min-width base media queries and up the page, we have "responsive" mode where we can decrease or increase freely
our screen there also we have a list of devices.

Now for making the typography responsive, let's take a look at the selectors that we have in that file in our website.
So let's decrease the size of viewport and see if those classes have problems in smaller sizes.

Also we need to get rid of our entire white border on small screen sizes. So let's do that in tab-port mode. So let's get rid of
padding for body which is in _base.scss file on smaller screens. So until 900px of viewport width, we don't need to have an overall
padding on body.

Also don't forget to check your responsive design on real phones and tablets too. Rather than only check it on responsive mode
or other devices in chrome devtools.

After make typography responsive, let's go to layout folder and in there let's first make the grid responsive. In order to do that,
go back to website and see what happens to grid when the viewport width gets less(why testing less? Because we are using desktop-first
approach- if we were on mobile-first, the things were opposite.)
Now you see the grid with 4 columns gets really small and where we should change it is in 900px breakpoint. Because even in for
example 860px the columns are too narrow and we can't wait to reach the smaller breakpoint which is 600px, because it would be
horrible. In other words, even BEFORE we arrive at 600px breakpoint we had a HORRIBLE design, so it's not good to just make those
grids responsive only when we arrive to 600px. So we must make things about grid right, in 900px breakpoint.(We only have those
2 breakpoints there and there's not other breakpoint between them.)

Important: We can simply make the width of all of those columns in grid to 100% and that's what usually is done on MOBILE DEVICES.
 So all the columns are transformed into rows actually because of making them to have width of 100%. So the entire mobile version of
 our webpage will have only one single column basically.
So let's add our mixin media query to {} of [class^="col-"] , because we want to make all of our columns responsive and all of them
has this shared style. Since the columns are no longer side by side, we don't need that horizontal gutter.
Also we need to remove any margin from those columns. Because right now, they all have a horizontal-gutter on their margin-right.
So let's again include that mixin into {} of where that margin-right is declared.
Important: Where ever you have some styles and you want to make them responsive, you MUST include that mixin into {} of those styles.
 Even if you already included that mixin in parent selector of the selector of styles that you want to make them responsive, you
 must include it AGAIN. For example see _grid.scss .

Now we need to also change the vertical gutter which currently on all devices is 8rem but it's too much for smaller devices(also
remember on smaller devices 1rem is no longer 10px, because we changed the font-size of html in base.scss for those devices.).
So let's create a new variable for vertical gutter for smaller devices.

After making the header responsive, the navigation button is moving to the center of page so let's take it back to corner in order to
be aligned in one line with the logo of page. So let's go to _navigation.scss and there we have to change &__button and we know that
the navigation button, starts to coming to center of page from around the tab-port breakpoint.
Also because you change the position of &__button in that point, you also need to change the &__background at that point, because
it is right under the &__button. And because both are cocentric. For values of top and right for respond media query of &__background,
we say that for &__button, we decrease the top and right by 2rem therefore we need to ALSO decrease those props for &__background by
2rem, because they most stay cocentric. Because in &__button, we had 6rem - 2rem = 4rem(the new top and right for tab-port and also
this happens for &__background). Also remember, because those 2 classes are cocnetric, if one of them have a media query for phones, the
other one also must have it with it's special values. Because we can't move on of them in one device but the other one stays there.

Now the final layout to make it responsive is footer. Now you can see that the CONTENT of .row class in footer is not in center(but
.row itself is centered). And let's also give it 100% width just like what we did with columns. So go to .footer.scss

Remember: The most crucial breakpoints are tab-port and phone and for other breakpoints the change that we do would be probably
only the root font-size which causes entire elements of page to smaller and just that change was enough for tab-land in order to
make the page looking good for 900-1200px viewport.

We should also have some padding on the .row on the left and right side of it, on smaller screens. Because on very small screen like
under 470, because we have some columns which are direct children of a .row and the .row in that point has a width of 50rem and
we set the width of columns in that small width, to be 100%. So that's why the content of footer is very close to edges of viewport
and we don't want that, so we can give row some padding in those small devices. Also the same thing is happening at those 3 cards section
and ... . So let's go to grid and give padding to left and right of .row.

Also now(under 900px viewport), the webpage is larger than device screen! therefore we need to fix it. So we got a horizontal scrollbar.*/
/* 5. Writing media queries - Layout, features and about sections:
Important: It turns out that the horizontal scrollbar that I mentioned was it had nothing to do with media queries, it was
 a bug in devtools and I have to was to click on toggle device toolbar and again click back.
Now let's remove the space in footer and go to &__logo-box of footer.

Now we took care all of our layouts in layout folder. After that let's go to pages folder and home.scss . But first let's take
a look at our website, before making any changes for responsive. As you can see we have a lot of space in general in our page.
So all of the sections have too much padding and you can see those spaces at 900px and in that breakpoint, we can see it already
starts to have too much padding in each section.
Also you can even decrease those paddings for mobile devices as well.

I saw too much space that u-margin-bottom-big is causing which it's sitting on the first direct child of section-tours.
So as you saw, you can add media queries to utilities file as well and since the normal styles in there have !important, we also
need to give the styles in media queries !important as well.

Now after layouts, let's go to components folder.
In composition component, we want images to be side by side in smaller screens and the middle image is a bit bigger than the other
2 and is on top of the other ones. So we need to make a lot of changes for that.
Now let's see where the composition starts to look really bad?
Close to 900px range.

Learn: If you want to give an element a float, it shouldn't have position: absolute; otherwise it wouldn't work. But if you really
 need that element to be positioned with top and right and ... and also need a float prop, you can give it a relative postion instead
 of absolute one.

After composition made responsive, let's go to feature-box and give it less padding than what it currently has.*/
/* 6. Writing media queries - tours, stories and booking sections:
Right now, we actually have to touch the tour cards in order to rotate the card. Because in touch devices, there's no such thing as
a hover. So the only way to actually rotate the card is to click it and that's not practical. So we must find a way to change the
entire cart. So on smaller screens, the part that was originally on the back, will be at the bottom of each card and we do that,
once the width of screen is smaller than 900px. So let's go to card.scss . But this time making responsive is different, because
this time we need a whole rewrite of an entire thing which in this case is card and therefore we're not just tweaking some stuff
there. So let's include our media query at the end of the .card(why not including it for each selector of that thing? Because
we wanna change a lot of the styles in that selectors and that's not good to include that mixin multiple times, so we put that
mixin at the (end of the) .card and then we put the selectors and their styles that we want to change based on the breakpoint of
that media query in there) which that thing exists on that file.
Why not including it at the end of the FILE itself?
Well because if we put it at the end of the file, there's no selector that we're writing our media query for it and therefore
you need to again write .card inside the block of code you pass to @content and that's a duplication. So put it inside .card and
then if you want to change the styles of for example .card-<x> you need to add that selector in {} of that mixin and then write
the styles for that selector.
Because remember, with this approach(using that mixin for media query and ...), we actually need to change the styles of A SELECTOR.
So we need to specify that selector in {} of mixin to pass that selector and it's styles to @content in order to apply the media
query for them.

After making the _card.scss responsive, let's go to _story.scss and in there let's make the story class from non-rectangular
to a rectangular, so it can really fit more text, therefore we don't waste all of the white space that we have on the sides of
story section. Because currently we have a big waste of space and we don't need that much space on small screens.
So for .story of story component, include the media query mixin.

If you have a page, online somewhere, then you can enter it's url in sizzy.co and then it will show you that website on a lot of
different devices.

Now let's make the popup responsive. We can put those 2 images on top of the popup or at the bottom. TODO*/

/* 7. An overview of responsive images
Currently, we do have flexible images already. In other words, our images currently nicely scale with the viewport width, but
responsive images take things to a whole new level and that's because responsive images are not only in aspect of responsive design,
but even more importantly of web performance. So responsive images are crucial for web performance.
(Remember we had: Responsive design-maintainable and scalable code-web performance)

What are responsive images anyway?
The goal(philosophy behind) of responsive images is to serve the right image for the right screen size and device, by using different
techniques in HTML and css, so that users don't have to download images that are way too large for their devices(in other words,
in order to avoid downloading unnecessary large images on smaller screens.).
For example, let's suppose the image for hero section is 1MB large. Now it may be absolutely ok to send that 1MB image to a
desktop user but it's not ok to send that 1MB to phone user which may have slow or expensive data plan somewhere in the world.
So we must use responsive images. So instead of sending 1MB to whatever device is using the page, we need to send 1MB image to device
with a large screen and much smaller version of that image to the device with small screen, which doesn't need such a large image
anyway.

Now in which situation, should we actually use responsive images?(When to use responsive images?-The 3 use cases.)
1) The first use case is called resolution switching and all that we do in resolution switching is to serve up the same image for
a smaller screen but with a smaller resolution. In other words, we decrease the image resolution on smaller screens. So same image,
but a smaller version for devices that don't need such a big image.

2) Density switching which is a special case of resolution switching, where the screen size doesn't matter but the screen pixel density
does instead.
But what is pixel density?
Pixel density is amount of pixels found in an inch or a centimeter.
Now what matters to devs is that there are low resolution screens and high resolution screens. Low resolution screens are just
typical PC screens and they can be called 1x screens. Because they use one pixel to display one pixel of our design. So if we say
an image should be 100 pixels high, those typical screens would use 100 physical pixels on the screen to display these 100px that
we specified for that image.
But high resolution screens are the ones found in all modern smart phones and even some computers like macBooks with retina displays.
These are high resolution screens and they can be called 2x screens because they actually use 2 physical pixels to display 1 pixel of
our design. So if we say we want an image to be 100 pixels high, it will actually be 200 pixels in a physical modern screen and that
all happens automatically of course. Now what does that mean for all of our images?
It means that if we want our images to look sharp on high-resolution screens which use double of amount of pixels, then we actually
have to serve an image with double the resolution of that original image and that's what density switching is for.
Learn: So density switching is for serve one image to a high resolution screen and another image if the screen is low resolution.
So if we have @2x screens(high-res) and want to serve the image that we had there, on @1x screen(low-res) we need to serve half the
image resolution on that @ix screen.

3) Art direction: This happens when you don't just want to serve the SAME image BUT in smaller resolution version of that image, but
A WHOLE different image for a different screen size. For example you may want to keep the important details in an image but remove
parts of that image around these details, just like the example of slides, where the size of the details(those square and triangle are
details) doesn't even change on a smaller screen and just stays the same. Or you could also load a completely different image altogether
and responsive images actually allow you to do that. So in art direction in small screens, image details were preserved but the image
is different, so different image on smaller screen.

Important: In conclusion: Resolution and density switching, are for when you want to serve the SAME image but with
 different resolutions and art direction is when you want to serve a completely different image on smaller screens.

Now why we're even talking about these different situations?
Because it's crucial to distinguish between the different those use cases, because they require us to use different solutions in
our HTML and css code. So we have to choose accordingly. */
/* 8. Responsive images in HTML - Art direction and density switching:
Let's implement density switching in art direction in HTML. In this lecture you'll learn:
1) How to use srcset attr on the <img> and <source> elements, together with density descriptors
2) How and why to use <picture> element for art direction
3) How to write media queries IN HTML
So this lecture would be about responsive images in html. Now what's the difference between images in HTML and in CSS?
Basically, with images in HTML, we simply mean all the img text, so all the image text where in that image text, we specify a source for
that image. For example in our logo, the img in html(img text) is: http://127.0. ... and the images in css, are when we use a background-image
in our styles, where in there we specify the url() . In our project, the background image of form, the images on cards(which are background-images,
right? Because in css, for specifying an image, you must use background-image.). So that's the difference of images in html and css.

Important: For making images, responsive, if that image was a css based image, we will use css in order to make it responsive and for the
 other images(the html images), we will do stuff in html and not css in order to make them responsive.
Now, let's start with html based images, because there are actually more technologies for doing responsive images in html(making the html
images responsive.) */

/* My notes:
The universal selector is one of the worst performers, alongside attribute selectors (like [href="#"]) and pseudo-classes and 
pseudo-elements. IDs and classes are the best for speedy performance.
Therefore, when writing selectors, it's best to put something performant like a class or ID at the end.

One way for align inline elements inside their containers is to set line-height of those inline elements, equal to height of their
container, so PROBABLY you need to set an explicit height for that container, but if you don't set any height for it, it's height would
be calculated based on it's content, which if we ONLY had that inline element which we set a line-height for it, the height of that
container would be equal to the line-height of that alone inline element. But anything that you do, always remember, for centering an
inline element vertically inside it's container, the line-height of inline element and height of it's parent must be equal.*/



















